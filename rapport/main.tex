\documentclass[12pt,a4paper]{article}

% Packages essentiels
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{array}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{enumitem}

% Configuration
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

% Listings Java
\lstset{
    language=Java,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!50!black}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    xleftmargin=15pt
}

% Hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan,
    breaklinks=true,
    pdftitle={Rapport JADE - Systèmes Multi-Agents}
}

% En-tête
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Système Multi-Agents - JADE}
\fancyhead[R]{M1 Informatique}
\fancyfoot[C]{\thepage}

\usetikzlibrary{positioning,shapes,arrows}

\begin{document}

% PAGE DE TITRE
\begin{titlepage}
    \centering
    \vspace*{5cm}

    {\Huge \textbf{Système Multi-Agents}}\\[0.5cm]
    {\Huge \textbf{ avec JADE}}\\[1cm]
    {\Huge \textbf{-}}\\[1cm]
    
    {\Large \textbf{Université de Caen Normandie}}\\[0.5cm]
    {\large UFR SCIENCES}\\[0.5cm]
    {\large M1 Informatique - SMINF1F5}
    
    \vfill
     
    \begin{tabular}{ll}
        \textbf{Auteurs} : & Hadjer CHEDJARI EL MEUR \\ & Etienne BOSSU \\
        \textbf{Date} : & Janvier 2026 \\
    \end{tabular}
\end{titlepage}

\tableofcontents
\newpage





% 1- Intro

\section{Introduction}

\subsection{Contexte}

Ce projet s'inscrit dans l'UE "Systèmes Multi-Agents" et vise à implémenter une solution décentralisée à un problème d'ordonnancement dans un atelier de production en utilisant la plateforme JADE.

\subsection{Objectifs}

\begin{itemize}
    \item Implémenter une solution \textbf{décentralisée} au problème d'ordonnancement
    \item Adapter le \textbf{Contract Net Protocol} pour l'allocation de tâches
    \item Coordonner des agents autonomes via négociation par enchères
    \item Optimiser l'utilisation des ressources (robots)
\end{itemize}

\subsection{Problématique}

Des robots aux compétences diverses doivent collaborer pour fabriquer des produits, en gérant :
\begin{itemize}
    \item L'arrivée des produits
    \item La variabilité des compétences
    \item Les possibles échecs d'exécution
    \item Les files d'attente de chaque robot
\end{itemize}





% 2 - Analyse du pb

\section{Analyse du Problème}

\subsection{Contraintes du Système}

\begin{table}[H]
\centering
\small
\begin{tabular}{|c|p{7cm}|c|}
\hline
\textbf{\#} & \textbf{Contrainte} & \textbf{Statut} \\
\hline
1 & 1 agent Atelier et $m$ agents Robots & \checkmark \\
2 & $N$ compétences distinctes & \checkmark \\
3 & Arrivée produit $\in [\lambda_1, \lambda_2]$ & \checkmark \\
4 & Chaque produit nécessite $N_j$ compétences & \checkmark \\
5 & Robots avec $S_i$ compétences, $p_{s_i,k} \in ]0,1[$ & \checkmark \\
6 & Robots peuvent partager compétences & \checkmark \\
7 & Probabilité $p_{s_i,k}$ de succès & \checkmark \\
8 & Robot qui échoue recommence & \checkmark \\
9 & Un robot = un produit à la fois & \checkmark \\
10 & File d'attente possible & \checkmark \\
11 & Communication non bloquante & \checkmark \\
12 & Pas de traitement simultané & \checkmark \\
\hline
\end{tabular}
\caption{État d'implémentation (\checkmark = Implémenté, $\times$ = Non implémenté)}
\end{table}

\subsection{Paramètres}

\begin{itemize}
    \item $m$ : Nombre de robots (défaut : 3)
    \item $N$ : Compétences disponibles (5)
    \item $N_j$ : Compétences par produit (3)
    \item $S_i$ : Compétences par robot (3)
    \item $\lambda_1, \lambda_2$ : Intervalle génération (1000-2000ms)
    \item $\lambda_3$ : Temps exécution (500ms)
    \item $p_{s_i,k}$ : Probabilité succès $\in [0.5, 1.0]$
\end{itemize}

\subsection{Contract Protocol}

\begin{enumerate}
    \item \textbf{Génération} : Atelier $\to$ robot aléatoire
    \item \textbf{Enchère} : Robot lance CFP pour compétence manquante
    \item \textbf{Soumission} : Robots qualifiés proposent makespan
    \item \textbf{Attribution} : Sélection minimum
    \item \textbf{Exécution} : Robot gagnant traite
    \item \textbf{Itération} : Jusqu'à complétion
    \item \textbf{Retour} : Produit fini $\to$ atelier
\end{enumerate}







% 3 - Conception

\section{Choix de Conception}

\subsection{Représentation des Produits}

\textbf{Classe Product :}
\begin{lstlisting}
public class Product implements Serializable {
    private String id;
    private HashMap<String, Boolean> requiredSkills;
    private long startTime;
    private int nbFailures = 0;
    
    // Methodes: isFinished(), getNextMissingSkill(), 
    //           setSkillDone(skill), addFailure()
}
\end{lstlisting}

\textbf{Justification :}
\begin{itemize}
    \item \textbf{HashMap} : Permet de suivre dynamiquement l'état de chaque compétence requise (réalisée ou non) par des valeurs booléennes.
    \item \textbf{Sérialisation} : L'implémentation de l'interface \texttt{Serializable} est requise pour transmettre l'objet complet dans le contenu des messages ACL entre agents.
    \item \textbf{Statistiques} : Les attributs \texttt{startTime} et \texttt{nbFailures} assurent le suivi précis du temps de cycle et de la fiabilité du processus pour chaque produit.
\end{itemize}

\subsection{Représentation des Compétences et Annuaire}

Les compétences sont représentées par des identifiants textuels allant de \texttt{"0"} à \texttt{"4"}. Chaque robot stocke ses aptitudes dans une \texttt{HashMap<String, Double>} associant l'identifiant du skill à sa probabilité de succès $p_{s_i,k}$.

La découverte des services repose sur le \textbf{Directory Facilitator (DF)} de JADE :
\begin{itemize}
    \item \textbf{Service général} : Chaque robot publie un service \texttt{"robot-service"} pour signaler sa présence dans l'atelier.
    \item \textbf{Services spécifiques} : Un service distinct est enregistré pour chaque compétence possédée (ex: \texttt{"skill-2"}), permettant au Manager de cibler uniquement les robots qualifiés lors d'un appel d'offres.
\end{itemize}

\subsection{Justification des Behaviours}

L'architecture logicielle utilise différents types de comportements JADE pour garantir l'asynchronisme et la simulation temporelle.

\subsubsection{AtelierAgent}
\begin{description}
    \item[\texttt{GenerateProductBehaviour} (WakerBehaviour)] \hfill \\
    Introduit un délai aléatoire compris entre $\lambda_1$ et $\lambda_2$ avant la création de chaque produit, se reprogrammant lui-même pour assurer un flux continu.

    \item[\texttt{ReceiveFinishedProductBehaviour} (CyclicBehaviour)] \hfill \\
    Maintient une écoute constante de la boîte aux lettres pour traiter les retours de produits finis sans interrompre les autres tâches de l'agent.
\end{description}

\subsubsection{RobotAgent}
\begin{description}
    \item[\texttt{ReceiveNewProductBehaviour} \& \texttt{ResponderBehaviour}] \hfill \\
    Comportements cycliques dédiés à l'interception des messages INFORM, CFP et ACCEPT. Ils garantissent que le robot reste disponible pour la négociation même en période d'activité.

    \item[\texttt{ManagerBehaviour} (OneShotBehaviour)] \hfill \\
    Exécuté ponctuellement lorsqu'un produit nécessite une compétence externe pour initier le protocole d'appel d'offres via le DF.

    \item[\texttt{CollectProposalsBehaviour} (WakerBehaviour)] \hfill \\
    Définit une fenêtre temporelle fixe de 1000ms pour collecter les propositions des robots avant de désigner le vainqueur de l'enchère.

    \item[\texttt{WorkerBehaviour} (TickerBehaviour)] \hfill \\
    Scanne la file d'attente toutes les 200ms. Le travail effectif est simulé par un \texttt{WakerBehaviour} de durée $\lambda_3$ pour éviter de geler l'exécution des autres comportements.
\end{description}

\subsection{Calcul du Makespan et Espérance}

Lors des enchères, les robots estiment leur temps de traitement restant (makespan). Ce calcul intègre l'espérance mathématique d'une loi géométrique pour modéliser l'impact des échecs potentiels :
\begin{equation}
E(\text{essais}) = \frac{1}{p} \implies \text{Échecs moyens } (E) = \frac{1 - p}{p}
\end{equation}

\textbf{Implémentation :}
\begin{lstlisting}
double E = (1.0 - prob) / prob;
// Estimation : temps nominal multiplie par le nombre d'essais esperes
totalTime += lambda3 * (1.0 + E);
\end{lstlisting}





% 4 - Communication
\section{Protocole de Communication}

\subsection{Messages FIPA-ACL}

Le système s'appuie sur le standard FIPA-ACL pour assurer l'interopérabilité entre les agents. Le tableau suivant récapitule les échanges au sein de l'atelier :

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Performative} & \textbf{De} & \textbf{Vers} & \textbf{Contenu (Object/String)} \\
\hline
INFORM & Atelier & Robot & Objet \texttt{Product} initial \\
INFORM & Robot & Atelier & Objet \texttt{Product} terminé \\
CFP & Manager & Workers & Identifiant \texttt{"skill-X"} \\
PROPOSE & Worker & Manager & Valeur du \texttt{makespan} estimé \\
ACCEPT\_PROPOSAL & Manager & Winner & Objet \texttt{Product} à traiter \\
\hline
\end{tabular}
\caption{Synthèse des interactions FIPA-ACL}
\end{table}

\subsection{ConversationId et Unicité}

Afin de permettre aux agents de distinguer plusieurs enchères se déroulant simultanément, chaque protocole de négociation est identifié par une clé unique.

\textbf{Format implémenté :} \texttt{"nego-" + productId + "-" + timestamp}

L'ajout du \texttt{System.currentTimeMillis()} garantit qu'un même produit, s'il doit subir plusieurs phases de négociation successives pour différents skills, ne créera pas de confusion dans les boîtes aux lettres des robots ouvriers.

\subsection{MessageTemplate et Filtrage}

L'utilisation des \texttt{MessageTemplate} est systématique pour assurer que chaque comportement ne traite que les messages qui lui sont destinés, sans perturber les autres files d'attente de l'agent.

\begin{lstlisting}[caption={Exemples de filtrage utilisés dans le projet}]
// Filtrage simple par performative (Reception de produit)
MessageTemplate.MatchPerformative(ACLMessage.INFORM)

// Filtrage combine pour la collecte des offres
MessageTemplate.and(
    MessageTemplate.MatchPerformative(ACLMessage.PROPOSE),
    MessageTemplate.MatchConversationId(conversationId)
)
\end{lstlisting}

\subsection{Suivi de la charge réseau}

Conformément aux exigences du sujet, chaque envoi de message déclenche l'incrémentation d'un compteur global situé dans la classe \texttt{Utils}. Ce mécanisme permet à l'Atelier d'afficher le coût total en communications de la simulation à chaque produit terminé.




% 5 - Implémentation 



\section{Implémentation Détaillée}

Cette section détaille les mécanismes internes et les algorithmes mis en œuvre pour assurer la coordination et la robustesse du système.

\subsection{AtelierAgent : Flux de Production}

L'Atelier gère le cycle de vie initial et final des produits. Son attribut principal est un objet \texttt{Random} permettant de simuler l'aléa de production.

\textbf{Algorithme de Génération :}
\begin{enumerate}
    \item Instanciation de \texttt{Product} avec un ID incrémental.
    \item Appel à \texttt{Utils.getRandomRobot()} : effectue un \texttt{DFService.search} pour trouver les robots disponibles et en sélectionne un par tirage uniforme.
    \item Transmission du produit par un message \texttt{INFORM}.
    \item Calcul du prochain délai via : $\lambda_1 + (rnd.nextDouble() \times (\lambda_2 - \lambda_1))$.
\end{enumerate}

\begin{lstlisting}[caption={Reprogrammation du comportement de génération}]
protected void onWake() {
    Product p = new Product("P-" + (++productCount), 5, 3);
    AID robot = Utils.getRandomRobot(myAgent);
    if (robot != null) {
        ACLMessage msg = new ACLMessage(ACLMessage.INFORM);
        msg.addReceiver(robot);
        msg.setContentObject(p);
        send(msg);
    }
    // Planification du prochain produit (Boucle infinie)
    myAgent.addBehaviour(new GenerateProductBehaviour(myAgent, getRandomTime()));
}
\end{lstlisting}

\subsection{RobotAgent : Négociation et Exécution}

\subsubsection{Initialisation et Compétences}
Lors du \texttt{setup()}, chaque robot s'attribue 3 compétences aléatoires. Pour chaque compétence, une probabilité de succès $p \in [0.5, 1.0]$ est définie. Cette valeur est critique car elle influence directement les offres faites lors des enchères.

\subsubsection{Cycle de Négociation (Contract Net)}
Lorsqu'un produit nécessite une compétence que le détenteur actuel ne possède pas (ou n'a plus besoin), l'agent bascule en rôle de \textbf{Manager} :
\begin{itemize}
    \item \textbf{Appel d'offres} : Envoi d'un \texttt{CFP} à tous les agents proposant le service \texttt{"skill-X"} dans l'annuaire.
    \item \textbf{Évaluation} : Le \texttt{CollectProposalsBehaviour} reçoit les propositions (\texttt{makespan}) et sélectionne l'agent ayant le temps de traitement estimé le plus court.
    \item \textbf{Transfert} : Envoi d'un \texttt{ACCEPT\_PROPOSAL} contenant l'objet \texttt{Product} sérialisé.
\end{itemize}

\subsubsection{Exécution et Gestion des Échecs}
Le travail effectif est géré par le \texttt{WorkerBehaviour}. C'est ici qu'est implémentée la logique de résilience demandée par le sujet.

\textbf{Logique de reprise sur erreur :}
\begin{lstlisting}
// Dans le onWake() du simulateur de travail
double prob = skills.get(skillToApply);
if (Math.random() < prob) {
    // SUCCES : Mise a jour de l'etat et redirection
    currentProduct.setSkillDone(skillToApply);
    myAgent.addBehaviour(new ManagerBehaviour(currentProduct));
} else {
    // ECHEC : Incrementation du compteur et reinsertion prioritaire
    currentProduct.addFailure();
    productQueue.add(0, currentProduct);
}
isWorking = false;
\end{lstlisting}

\subsection{Suivi des Statistiques et Performance}

Le système intègre un monitoring en temps réel pour évaluer l'efficacité de l'ordonnancement.

\subsubsection{Analyse de la Fiabilité}
L'échec est traité comme une donnée métier. Le compteur \texttt{nbFailures} est encapsulé dans le \texttt{Product} et voyage avec lui. À l'arrivée, l'Atelier calcule la moyenne globale, permettant d'identifier si la difficulté des tâches est en adéquation avec les capacités des robots.

\subsubsection{Coût de Communication}
Pour mesurer la charge réseau sans surcharger le système, nous utilisons un \texttt{Atomic\-Integer} dans une classe utilitaire.
\begin{itemize}
    \item \textbf{Avantage} : Garantit l'intégrité du compteur malgré les accès concurrents des agents.
    \item \textbf{Calcul} : Chaque message (\texttt{send}) incrémente le total. Cela permet de corréler le nombre de messages avec le nombre de robots.
\end{itemize}


% ============= SECTION 6: DIAGRAMME =============
\section{Diagramme de Séquence}
\begin{figure}[H] 
    \centering
        \includegraphics[width=0.75\linewidth]{diagramme.png}
    \caption{Diagramme de séquence du protocole de négociation}
    \label{fig:seq_diag}
\end{figure}
Le schéma ci dessus résume le scénario nominal de communication : l'Atelier lance la production et les robots utilisent des appels d'offres (CFP) pour se répartir le travail étape par étape.

% ============= SECTION 7: UTILISATION =============
\section{Guide d'Utilisation}

Le projet est fourni avec une structure prête à l'emploi. Les dépendances JADE sont situées dans le dossier \texttt{lib/} et les sources dans le dossier \texttt{src/}.


\subsection{Scripts de Lancement}

Des scripts automatisés sont fournis pour simplifier l'exécution et la génération de la documentation technique.

\subsubsection{Exécution (run.bat / run.sh)}
Ces scripts permettent de lancer la simulation avec des paramètres par défaut ou personnalisés.

\textbf{Usage :}
\begin{lstlisting}[language=bash]
# Sous Windows
run.bat [nbRobots] [lambda1] [lambda2] [lambda3]

# Sous Linux/Mac
./run.sh [nbRobots] [lambda1] [lambda2] [lambda3]
\end{lstlisting}

\subsubsection{Documentation (doc.bat / doc.sh)}
Ces scripts génèrent la documentation Javadoc.

\begin{lstlisting}[language=bash]
# Generation de la Javadoc
./doc.sh
\end{lstlisting}

\subsection{Configuration de la Simulation}

Le programme \texttt{Main} accepte les paramètres suivants en ligne de commande :
\begin{enumerate}
    \item \textbf{nbRobots} : Nombre d'agents Robots à instancier (défaut : 3).
    \item \textbf{lambda1 / lambda2} : Intervalle de génération des produits pour l'Atelier.
    \item \textbf{lambda3} : Temps de traitement nominal pour les robots.
\end{enumerate}

\subsection{Sorties Console et Traces}

Les traces d'exécution permettent de suivre en temps réel les négociations et l'état des stocks de chaque robot.

\begin{lstlisting}[caption={Traces d'execution et statistiques de production}]
Atelier Atelier pret.
Robot Robot1 pret. Competences: {1=0.80, 4=0.54}
Robot Robot2 pret. Competences: {2=0.67, 4=0.96}
Atelier : Produit P-1 envoye a Robot2

V [Worker Robot2] Produit recu : P-1 (File: 1)
*** [Worker Robot2] SUCCES sur P-1
!!! [Manager Robot2] Aucun robot trouve pour le skill 3

--------------------------------------------------
--- PRODUIT FINI : P-1 ---
   > Termine par       : Robot2
   > Temps de cycle    : 4768 ms
   > Echecs sur ce P   : 0
   > Moyenne echecs    : 0.00
   > Total Messages    : 37
--------------------------------------------------
\end{lstlisting}




% 8 - Conclusion et Analyse

\section{Analyse des Résultats et Conclusion}

\subsection{Bilan Technique et Points Forts}

Le système multi-agents développé remplit l'ensemble des objectifs fixés par le cahier des charges. L'approche décentralisée, portée par la plateforme JADE, a permis de créer un environnement de production autonome. 

Parmi les points forts de cette implémentation, nous pouvons noter :
\begin{itemize}
    \item \textbf{Robustesse et réalisme} : L'intégration d'une logique d'échec et la réinsertion prioritaire des produits en file d'attente simule fidèlement les aléas d'un atelier réel.
    \item \textbf{Optimisation par le Makespan} : Le calcul du temps de traitement incluant l'espérance mathématique des échecs permet une allocation intelligente des tâches, favorisant les robots les plus performants.
    \item \textbf{Monitoring précis} : Grâce à l'instrumentation de la classe \texttt{Utils} et l'usage de compteurs \texttt{AtomicInteger}, nous obtenons un suivi rigoureux de la charge réseau et du coût de communication du protocole \textit{Contract Net}.
\end{itemize}

\subsection{Limites et Perspectives d'Évolution}

Malgré l'efficacité globale du système, l'analyse des logs a mis en évidence une vulnérabilité critique liée à la distribution aléatoire des compétences. Si une compétence n'est possédée par aucun robot au démarrage, le système entre dans une impasse où certains produits ne peuvent jamais être terminés.

Pour résoudre ce problème ou améliorer ce projet, plusieurs améliorations sont envisageables :
\begin{itemize}
    \item \textbf{Contrôle de couverture} : Implémenter un agent superviseur vérifiant la présence de tous les services nécessaires dans l'annuaire DF avant d'autoriser le lancement de la production par l'Atelier.
    \item \textbf{Interface Graphique} : Bien que les traces console soient complètes, une interface de visualisation en temps réel permettrait de mieux observer les flux de produits entre les robots.
\end{itemize}

\end{document}